#!/usr/bin/env python
#
# Copyright (C) 2002 Gre7g Luterman <gre7g@wolfhome.com>
#
# This file is part of TMDA.
#
# TMDA is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  A copy of this license should
# be included in the file COPYING.
#
# TMDA is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with TMDA; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

"""Pending queue manipulation tool.

Usage:  %(Program)s [OPTIONS]

Where:
    -b <path>
    --base-dir <path>
       Specify a path to TMDA.

    -c <file>
    --config-file <file>
       Specify a different configuration file other than ~/.tmda/config.

    -d <path>
    --display-dir <path>
       Specify a different directory for supplimental display files (icons and
       stylesheet).

    -h
    --help
       Print this help message and exit.

    -i <path>
    --install-prefix <path>
       Specify path to tmda-cgi.py other than the current directory.

    -m system-wide|single-user|no-su
    --mode system-wide|single-user|no-su
       Specify an operating mode.

    -n
    --no-su
       Compile a CGI to run in no-su mode.  Forces option "-m no-su".

    -t <file>
    --target <file>
       Compile as a file other than ./tmda-cgi.

    -u <user>
    --user <user>
       Overrides the value of CGI_USER found in the configuration files.
       (Only affects system-wide mode.)

If you specify no options, then the program will run in an interactive mode,
provide defaults for all values, and remember the new values you give it as
future defaults in case you need to recompile later.

The -i and -m options are seldom needed.  These options are for the rare cases
when a user other than root needs to compile the program for use in system-
wide mode.  For the resulting code to run correctly, root will have to chown
the resulting program.

The target may be specified on the command line with the -t option.

You can specify the location of the supplimental display files (icons and
stylesheet) with the -d option.  The default location is:

    ../display/

Use the -c option to specify a different location for your TMDA configuration
file.  You may use a "~" anywhere in the path to specify "the current user".
For example:

    %(Program)s -c /var/tmda/~/config

Will look for configuration files at /var/tmda/<user>/config instead of the
usual ~<user>/.tmda/config.

If no ~ is specified, compile will make a "best guess".
"""

import compileall
import getopt
import os.path
import pickle
import pwd
import re
import string
import sys

def Ask(Question, OptD, Str):
  "Ask for a member from the keyboard."
  while 1:
    print Question
    Temp = raw_input("(%s): " % OptD[Str]).strip()
    if Temp:
      Limit = re.search("\[(.+,.+)\]", Question)
      if Limit and not (Temp in Limit.group(1).split(", ")): continue
      OptD[Str] = Temp
    break

def Interactive(OptD):
  "Get options interactively."
  Ask("Location of Python interpreter (version 2.1+)", OptD, "Python")
  Ask("Target filename (and location) to compile CGI", OptD, "Target")
  Ask("Path to TMDA root directory", OptD, "Base")
  Ask("Path to tmda-cgi Python files", OptD, "Path")
  Ask('User config file location (or "None" for system default)', OptD,
    "Config")
  Ask("Relative or absolute web path from CGI to display directory", OptD,
    "DispDir")
  if OptD["DispDir"][-1] != "/": OptD["DispDir"] += "/"
  Ask("CGI mode [system-wide, single-user, no-su]", OptD, "Mode")
  if OptD["Mode"] == "system-wide":
    Ask("User name to use while accessing session data", OptD, "User")
  print

Program = sys.argv[0]

Perm = 04755

# Keep options in one handy dictionary
OptD = {}
OptD["Python"]  = sys.executable
OptD["Target"]  = "tmda-cgi"
OptD["Base"]    = "../tmda/"
OptD["Path"]    = "."
OptD["DispDir"] = "../display/"
OptD["User"]    = "nobody"
if os.geteuid():
  OptD["Mode"] = "single-user"
else:
  OptD["Mode"] = "system-wide"
if os.environ.has_key("TMDARC"):
  OptD["Config"] = os.environ["TMDARC"]
else:
  OptD["Config"] = "None"

def Usage(Code, Msg=""):
  "Show usage information and possibly an error message."
  print __doc__ % globals()
  if Msg: print Msg
  sys.exit(Code)

try:
  Opts, Args = getopt.getopt(sys.argv[1:], "b:c:d:i:m:nht:u:",
    ["base-dir=", "config-file=", "display-dir=", "help", "install-prefix=",
     "mode=", "no-su", "target=", "user="])
except getopt.error, Msg:
  Usage(1, Msg)

# Handle any options passed in
for Opt, Arg in Opts:
  if Opt in ("-h", "--help"):
    Usage(0)
  elif Opt in ("-b", "--base-dir"):
    OptD["Base"] = Arg
  elif Opt in ("-c", "--config-file"):
    OptD["Config"] = Arg
  elif Opt in ("-d", "--display-dir"):
    if Arg[-1] == "/":
      OptD["DispDir"] = Arg
    else:
      OptD["DispDir"] = Arg + "/"
  elif Opt in ("-i", "--install-prefix"):
    OptD["Path"] = Arg
  elif Opt in ("-t", "--target"):
    OptD["Target"] = Arg
  elif Opt in ("-m", "--mode"):
    if not Arg in ("system-wide", "single-user", "no-su"):
      Usage(1, "Valid modes are system-wide, single-user, and no-su")
    OptD["Mode"] = Arg
  elif Opt in ("-n", "--no-su"):
    OptD["Mode"] = "no-su"
  elif Opt in ("-u", "--user"):
    OptD["User"] = Arg

# No options means interactive mode
if not len(Opts):
  # Try to load options from last interactive run
  try:
    F = open("compile.ini")
    OptD = pickle.load(F)
    F.close()
  except IOError:
    pass
  Break = 0
  try:
    Interactive(OptD)
  except KeyboardInterrupt:
    Break = 1
    print "\nSaving settings. Delete compile.ini to reset back to defaults."
  try:
    F = open("compile.ini", "w")
    pickle.dump(OptD, F)
    F.close()
  except IOError:
    pass
  if Break: sys.exit()

# Check that we're running in Python version 2.1 or higher
if sys.version.split()[0] < '2.1':
  print """Compile terminated.  tmda-cgi requires Python version 2.1 or higher.

Either install the latest version of Python or specify the appropriate Python
interpreter when you issue the compile command.  Instead of typing:

    $ ./compile <options>

Type:

    $ /usr/bin/python2 compile <options>

(Assuming that your Python 2.1+ can be found at /usr/bin/python2.)
The compiler will save the correct version of the Python interpreter and use it
when tmda-cgi is run."""
  sys.exit()

# Check that User is valid and unprivileged (system-wide mode only).
if OptD["Mode"] == "system-wide":
  try:
    if not pwd.getpwnam(OptD["User"])[2]:
      print """Compile terminated.  User may not be root.  Please specify a non-
privileged user with the -u option."""
      sys.exit()
  except KeyError:
    print """Compile terminated.  User not found.  Please specify a real, non-
privileged user with the -u option."""
    sys.exit()

OptD["Path"] = os.path.abspath(OptD["Path"])

if OptD["Mode"] == "no-su": Perm = 0755

# Create dirs.h
F = open("dirs.h", "w")
F.write("""#define PYTHON "%(Python)s"
#define INSTALL "%(Path)s"
#define MODE "TMDA_CGI_MODE=%(Mode)s"
#define USER "TMDA_CGI_USER=%(User)s"
#define DISP_DIR "TMDA_CGI_DISP_DIR=%(DispDir)s"
#define BASE_DIR "TMDA_BASE_DIR=%(Base)s"
""" % OptD)
if OptD["Config"] != "None":
  if OptD["Config"].find("~") >= 0:
    OptD["Config"] = string.replace(OptD["Config"], "/%s/" % os.environ["USER"], "/~/")
    print """NOTE:
tmda-cgi will look for config files at: %s
Where <user> will be replaced by the user's login name.
""" % string.replace(OptD["Config"], "/~/", "/<user>/")
  F.write("""#define TMDARC "TMDARC=%(Config)s"
""" % OptD)
F.close()

print "Compiling..."

# Remove any old tmda-rc
try:
  os.unlink(OptD["Target"])
except: pass

# Compile tmda-cgi
os.system("gcc tmda-cgi.c -o %s" % OptD["Target"])

# Remove dirs.h
os.unlink("dirs.h")

# Set permissions
try:
  os.chmod(OptD["Target"], Perm)
except OSError, (ErrNo, StrError):
  print "Compile aborted.  Error #%d: %s" % (ErrNo, StrError)
  sys.exit()

# Compile Python code
compileall.compile_dir(OptD["Path"])

print "Compilation done."
