#!/usr/bin/env python
#
# Copyright (C) 2001,2002 Jason R. Mastaler <jason@mastaler.com>
#
# Author: David Guerizec <david@guerizec.net>
#
# This file is part of TMDA.
#
# TMDA is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  A copy of this license should
# be included in the file COPYING.
#
# TMDA is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with TMDA; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

"""Tkinter interface to TMDA.

Usage: %(program)s [OPTIONS]

Where:
   <none>
   <none>
       Gives a functional (but yet to finish) Address generator interface.

   -p
   --pending
       Gives a functionnal (but yet to finish) Pending queue graphical
       interface.

        Until I do the Help dialog, here are some tips:
        . you can resize the list columns width
        . you can resize the height of the list
        . double-click on a message and you'll see it's content
        . the list is refreshed every 5 mins by default but you can
          change it in Edit/Settings... (not memorized between runs yet)

   -H hostname[:port]
   --host hostname[:port]
      Specify a hostname and a port to connect to.
      This is mandatory if you don't have a local installation of TMDA.

   -U username:password
   -user username:password
      Specify a username and a password to authenticate against on the
      remote host.
      See the NOTE below for security advisory.
      This is mandatory if you don't have a local installation of TMDA.

NOTE: This is early alpha software, so please try it, and send your
comments to the tmda-workers@tmda.net mailing list.

Please note that the options will be visible by any other local user on
your machine with the 'ps' command, so don't use the -U option if you don't
want to expose your password.
"""

import getopt
import os
import sys

try:
    import paths
except ImportError:
    # Prepend /usr/lib/python2.x/site-packages/TMDA/pythonlib
    sitedir = os.path.join(sys.prefix, 'lib', 'python'+sys.version[:3],
                           'site-packages', 'TMDA', 'pythonlib')
    sys.path.insert(0, sitedir)

## Lib access functions
def lib_getAddress(tag, option=None, address=None):
    try:
        tagged_address = Address.Factory(tag = tag).create(address, option).address
    except ValueError, msg:
        return ''

    return tagged_address

def lib_checkAddress(address, sender_address=None):
    #FIXME: Add localtime support
    localtime = None
    status = []
    try:
        addr = Address.Factory(address)
        addr.verify(sender_address)
        status.append("STATUS: VALID")
        try:
            status.append("EXPIRES: %s" % addr.timestamp(1, localtime))
        except AttributeError:
            pass
    except Address.AddressError, msg:
        status.append("STATUS: " + str(msg))

    return '\n'.join(status)

MessageError = "Message Error"
def lib_processMessage(msgid, command, **args):
    try:
        msg = Pending.Message(msgid)
    except Errors.MessageError:
        raise MessageError
    if command not in ('terse', 'show'):
        msg.initMessage()
    try:
        try:
            data = getattr(msg, command)(args)
        except TypeError:
            # if command takes no argument
            data = getattr(msg, command)()
        if type(data) == str:
            return data
        else:
            if command == 'show':
                print "Debug: type of data in lib_processMessage -> " + str(type(data))
            try:
                return '\n'.join(data)
            except TypeError:
                return str(data)
    except AttributeError:
        raise MessageError

def lib_processPending(command, **args):
    Q = Pending.Queue(descending=1).initQueue()
    if command == 'list':
        return Q.listPendingIds()
    return None

## Net access functions
import socket
sock = None
sin = None
sout = None

ProtoError = "Protocole Error"

def connectToServer(host, auth):
    global sock, sin, sout
    if sock:
        print "Already connected"
        return 0
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(host)
    sin = sock.makefile('r', 0)
    sout = sock.makefile('w', 0)
    # eat up greetings from manager
    ## FIXME: maybe check the protocol version ?
    while sin.readline() and sin.read(1) != '+':
        pass
    sout.write('auth %s %s\n' % auth)
    if sin.read(1) != '+':
        return 0
    return 1

def net_command(command):
    data = []
    sout.write(str(command)+'\n')
    cc = sin.read(1)
    while cc == ' ':
        data.append(sin.readline()[:-1])
        cc = sin.read(1)
    if cc == '-':
        msg = sin.readline()[:-1]
        ## FIXME: think about error recovery (check the '+')
        raise ProtoError, msg
    return data

def net_getAddress(tag, option=None, address=None):
    tagged_address = '\n'.join(net_command('address %s %s' % (tag, option)))
    return tagged_address

def net_checkAddress(address, sender_address=None):
    status = '\n'.join(net_command('checkaddress %s %s' % (address, sender_address)))
    print status
    return status

def net_processMessage(msgid, command, **args):
    try:
        data = net_command('message %s %s' % (command, msgid))
        return '\n'.join(data)
    except ProtoError, msg:
        print "%s: %s" % (ProtoError, msg)
        
    raise MessageError

def net_processPending(command, **args):
    if command == 'list':
        try:
            ## FIXME: add reverse option pending command
            data = net_command('pending only')
            data.reverse()
            return data
        except ProtoError, msg:
            print "%s: %s" % (ProtoError, msg)

    return []

# Let's check if we're running locally or through the network

try:
    from TMDA import Version
    from TMDA import Address
    from TMDA import Pending
    from TMDA import Errors

    using_network = 0
    getAddress = lib_getAddress
    checkAddress = lib_checkAddress
    processMessage = lib_processMessage
    processPending = lib_processPending


# No TMDA library around, we're not on the server
except ImportError:
    using_network = 1
    # Hack to have the --version flag
    class VersionObject:
        ALL = 'unknown'
        TMDA = 'unknown'
    Version = VersionObject()




try:
    from Tkinter import *
except ImportError:
    ## FIXME: what to do if we don't have TMDA ?
    from TMDA.Util import wraptext
    no_tk = 'It appears your Python is not configured with Tkinter ' + \
            'support. Visit http://python.org/topics/tkinter/trouble.html ' + \
            'for more information.'
    print 'ERROR:\n'
    print wraptext(no_tk), '\n'
    sys.exit()


program = sys.argv[0]

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)

try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'H:U:pVh',
                                        ['host=',
                                         'user=',
                                         'pending',
                                         'version',
                                         'help'])
except getopt.error, msg:
    usage(1, msg)

pending_first = 0
host = None
port = 8765
for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage(0)
    if opt == '-V':
        print Version.ALL
        sys.exit()
    if opt == '--version':
        print Version.TMDA
        sys.exit()
    if opt in ('-p', '--pending'):
        pending_first = 1
    elif opt in ('-H', '--host'):
        using_network=1
        try:
            (host, port) = arg.split(':', 1)
        except ValueError:
            (host, port) = (arg, 8765)
    elif opt in ('-U', '--user'):
        try:
            (user, passwd) = arg.split(':', 1)
        except ValueError:
            print "Error: missing the password"
            sys.exit()

if using_network:
    if not host:
        print "Error: no TMDA library available and no host to connect to."
        sys.exit()
    if not user or not passwd:
        print "Error: please provide a user:password pair to connect to remote host."
        sys.exit()

    # map the accessors to the net_* functions
    getAddress = net_getAddress
    checkAddress = net_checkAddress
    processMessage = net_processMessage
    processPending = net_processPending


##############################################
##  Some helper widgets                     ##
##############################################

class ProgressBar(Frame):
    def __init__(self, master=None, **args):
        Frame.__init__(self, master, args)
        self.pack(fill=BOTH, expand=YES)
        self.cursor = None
    
    def Show(self, max=100, step=1):
        self.Hide()
        self.cursor = Scale(self, showvalue=NO, orient=HORIZONTAL)
        self.cursor.pack(fill=BOTH, expand=YES)
        self.value = 0
        self.max = max
        self.cursor.configure(to=max)
        self.step = step
        self.update()

    def Inc(self):
        self.Update(self.value + self.step)
        
    def Update(self, value=-1):
        if value < 0:
            value = (self.value + self.step)
            print value
            if value > self.max or value < 0:
                self.step *= -1
                print self.step
                value = (value + 2 * self.step)

        self.value = value
        self.cursor.set(value)
        self.update()
        
    def Hide(self):
        if self.cursor:
            self.cursor.destroy()

class StatusBar(Frame):
    def __init__(self, master, **args):
        Frame.__init__(self, master, args)
        self.message = Label(self, bd=1, relief=SUNKEN)
        self.message.pack(side=LEFT, fill=X)

        self.progress = ProgressBar(self)
        self.progress.pack(side=RIGHT, fill=X)

    def Set(self, text, **args):
        args['text'] = ' ' + str(text) + ' '
        self.message.configure(args)
        self.update()


class HMultiSplitter(Frame):
    def __init__(self, master, number, **args):
        Frame.__init__(self, master, args)

        self.frames = [ Frame(self, bd=0, relief=SUNKEN) for x in range(number) ]
        
        max = len(self.frames)
        step = 1.0 / max
        y = 0
        for f in self.frames:
            f.place(rely=y, relheight=step, relwidth=1)
            if y > 0:
                sep = Frame(self, bd=2, relief=RAISED, width=8, height=2,
                                  cursor="sb_v_double_arrow")
                sep.place(relx=0, rely=y, anchor=W, relwidth=1)
                sep.bind('<ButtonPress>', self.Start)
                sep.bind('<ButtonRelease>', self.Stop)
                sep.split = y
                sep.fprev = fprev
                fprev.snext = sep
                sep.fnext = f
                f.sprev = sep
            y += step
            fprev = f

    def Start(self, ev):
        s = ev.widget
        s.splitpx = int(s.split * self.winfo_height())
        s.rsz = s.splitpx
        s.bind('<B1-Motion>', self.Move)
        s.place(relx=2) # hide the splitter during the move
        
    def Move(self, ev):
        s = ev.widget
        s.splitpx = s.rsz + ev.y
        s.split = (1.0 * s.splitpx) / self.winfo_height()
        try:
            if s.split < s.fprev.sprev.split:
                s.split = s.fprev.sprev.split
        except AttributeError:
            pass
        try:
            if s.split > s.fnext.snext.split:
                s.split = s.fnext.snext.split
        except AttributeError:
            pass
        try:
            s.fprev.place(relheight=s.split - s.fprev.sprev.split)
        except AttributeError:
            s.fprev.place(relheight=s.split)
        try:
            s.fnext.place(rely=s.split, relheight=s.fnext.snext.split-s.split)
        except AttributeError:
            s.fnext.place(rely=s.split, relheight=1.0-s.split)

    def Stop(self, ev):
        s = ev.widget
        s.bind('<B1-Motion>', lambda e: "break")
        s.place(relx=0, rely=s.split, anchor=W)


class VMultiSplitter(Frame):
    def __init__(self, master, number, **args):
        try:
            self.split = args['split']
            del args['split']
        except KeyError:
            self.split = 0.5
        
        Frame.__init__(self, master, args)

        self.frames = [ Frame(self, bd=0, relief=SUNKEN) for x in range(number) ]
        
        max = len(self.frames)
        step = 1.0 / max
        x = 0
        for f in self.frames:
            f.place(relx=x, relwidth=step, relheight=1)
            if x > 0:
                sep = Frame(self, bd=2, relief=RAISED, height=8, width=2,
                                  cursor="sb_h_double_arrow")
                sep.place(rely=0, relx=x, anchor=N, relheight=1)
                sep.bind('<ButtonPress>', self.Start)
                sep.bind('<ButtonRelease>', self.Stop)
                sep.split = x
                sep.fprev = fprev
                fprev.snext = sep
                sep.fnext = f
                f.sprev = sep
            x += step
            fprev = f

    def Start(self, ev):
        s = ev.widget
        s.splitpx = int(s.split * self.winfo_width())
        s.rsz = s.splitpx
        s.bind('<B1-Motion>', self.Move)
        s.place(rely=2) # hide the splitter during the move
        
    def Move(self, ev):
        s = ev.widget
        s.splitpx = s.rsz + ev.x
        s.split = (1.0 * s.splitpx) / self.winfo_width()
        try:
            if s.split < s.fprev.sprev.split:
                s.split = s.fprev.sprev.split
        except AttributeError:
            pass
        try:
            if s.split > s.fnext.snext.split:
                s.split = s.fnext.snext.split
        except AttributeError:
            pass
        try:
            s.fprev.place(relwidth=s.split - s.fprev.sprev.split)
        except AttributeError:
            s.fprev.place(relwidth=s.split)
        try:
            s.fnext.place(relx=s.split, relwidth=s.fnext.snext.split-s.split)
        except AttributeError:
            s.fnext.place(relx=s.split, relwidth=1.0-s.split)

    def Stop(self, ev):
        s = ev.widget
        s.bind('<B1-Motion>', lambda e: "break")
        s.place(rely=0, relx=s.split, anchor=N)


class MessageList(Frame):
    def __init__(self, master, statusbar=None, **args):
        Frame.__init__(self, master, args)
        self.statusbar = statusbar
        self._sb = Scrollbar(self, orient=VERTICAL)
        self._sb.config(command=self._yview)
        
        self._colnames = [ 'msgid', 'from_name', 'subject' ]
        self._collabels = { 'msgid': 'Date', 'from_name': 'From', 'subject': 'Subject', } 

        self._cols = []

        f = VMultiSplitter(self, len(self._colnames))
        f.pack(side=LEFT, fill=BOTH, expand=YES)
    
        for i in range(len(self._colnames)):
            Label(f.frames[i], text=self._collabels[self._colnames[i]],
                      bd=1, relief=RAISED).pack(side=TOP, fill=X)
            l = Listbox(f.frames[i], yscrollcommand=self._set, bd=0)
            l.pack(side=LEFT, fill=BOTH, expand=YES)
            self._cols.append(l)
        self._sb.pack(side=RIGHT, fill=Y)
    
    def curselection(self):
        for col in self._cols:
            selindex = col.curselection()
            if selindex:
                break
        return selindex

    def bind(self, key, action):
        for col in self._cols:
            col.bind(key, action)
        return None

    def _set(self, *args):
        for col in self._cols:
            col.yview(MOVETO, args[0])
        apply(self._sb.set, args)
        return None
        
    def _yview(self, *args):
        for col in self._cols:
            apply(col.yview, args)
        return None

    def WhitelistSelectedMessage(self):
        try:
            processMessage(self.msgs[int(self.curselection()[0])], command='whitelist')
        except IndexError:
            return 0
        self.Refresh()
        return 1

    def BlacklistSelectedMessage(self):
        try:
            processMessage(self.msgs[int(self.curselection()[0])], command='blacklist')
        except IndexError:
            return 0
        self.Refresh()
        return 1

    def ReleaseSelectedMessage(self):
        try:
            processMessage(self.msgs[int(self.curselection()[0])], command='release')
        except IndexError:
            return 0
        self.Refresh()
        return 1

    def DeleteSelectedMessage(self):
        try:
            processMessage(self.msgs[int(self.curselection()[0])], command='delete')
        except IndexError:
            return 0
        self.Refresh()
        return 1

    def GetSelectedMsgId(self):
        try:
            return self.msgs[int(self.curselection()[0])]
        except IndexError:
            return ''
        
    def GetSelectedMsgContent(self):
        try:
            return processMessage(self.msgs[int(self.curselection()[0])],
                                  command='show').split('\n\n', 1)
        except IndexError:
            return ('', '')
        
    def Refresh(self):
        try:
            for col in self._cols:
                col.delete(0, END)
            self.msgs = []
            lst = processPending('list')
            self.statusbar.Set('Please wait, loading message list...')
            self.statusbar.progress.Show(len(lst))
            x = 0
            for item in lst:
                self.statusbar.progress.Inc()
                try:
                    msg = processMessage(item, command='terse', date=1).split('\n')
                except MessageError:
                    # no such message
                    continue
                self.msgs.append(item)
                i = 0
                for col in self._cols:
                    col.insert(END, msg[i])
                    i = i + 1
            self.statusbar.progress.Hide()
        except TclError: # Refresh is probably aborted by user
            pass

class PendingGUI(Frame):
    AppName = "tmda-gui"
    refresh_interval = 300
    def __init__(self, master=None, statusbar=None, **args):
        if 0 and master:
            master.title(self.AppName)
            master.protocol("WM_DELETE_WINDOW", self.FileQuit)

        Frame.__init__(self, master, args)
        self.statusbar = statusbar

        self.menudef = [
            [
                { 'text': 'File', },
                { 'label': 'Open...',
                                'command': self.FileOpen, 'state': DISABLED, },
                { 'label': 'Save',
                                'command': self.FileSave, 'state': DISABLED, },
                { 'label': 'Save as...',
                                'command': self.FileSaveAs, 'state': DISABLED, },
                { 'label': 'Quit',
                                'command': self.FileQuit, },
            ],
            [
                { 'text': 'Edit', },
                { 'label': 'Undo',
                                'command': self.EditUndo, 'state': DISABLED, },
                { 'label': 'Settings...',
                                'command': self.EditSettings, },
            ],
            [
                { 'text': 'Message', },
                { 'label': 'Refresh',
                                'command': self.MessageRefresh, },
                { 'label': 'Show',
                                'command': self.MessageShow, },
                { 'label': 'Whitelist',
                                'command': self.MessageWhitelist, },
                { 'label': 'Release',
                                'command': self.MessageRelease, },
                { 'label': 'Blacklist',
                                'command': self.MessageBlacklist, },
                { 'label': 'Delete',
                                'command': self.MessageDelete, },
            ],
            [
                { 'text': 'Help', },
                { 'label': 'Help',
                                'command': self.HelpHelp, 'state': DISABLED, },
                { 'label': 'About',
                                'command': self.HelpAbout, },
            ],
        ]
        self.master=master
        self.createWidgets()
        self.counter = self.refresh_interval - 1
        self.poll()

    def FileOpen(self):
        print "opening file"
        from FileDialog import LoadFileDialog
        fd = LoadFileDialog(self)
        self.filename = fd.go(key="FIXME")
    
    def FileSave(self):
        print "saving file",
        try:
            print self.filename
        except AttributeError:
            self.FileSaveAs()
    
    def FileSaveAs(self):
        from FileDialog import SaveFileDialog
        fd = SaveFileDialog(self)
        self.filename = fd.go(key="FIXME")
        print "saved file as", self.filename
    
    def FileQuit(self):
        print "Exiting..."
        self.master.destroy()
    
    def EditUndo(self):
        print "undoing stuff"
    
    def EditSettings(self):
        self.ws = Toplevel(self)
        Label(self.ws, text="Refresh interval (sec)").grid()
        self.ws.ri = Entry(self.ws)
        self.ws.ri.insert(END, self.refresh_interval)
        self.ws.ri.grid(row=0, column=1)
        Button(self.ws, text="OK", command=self.UpdateSettings,
               relief=GROOVE).grid(columnspan=2)
        self.ws.transient(self)
        
    def UpdateSettings(self):
        try:
            self.refresh_interval = int(self.ws.ri.get())
        except:
            pass
        self.ws.destroy()
        del self.ws
    
    def HelpHelp(self):
        print "Help: blah blah blah..."
    
    def HelpAbout(self):
        abouttxt = """Copyright 2002 David Guerizec <david@guerizec.net>\n""" + \
                   """Copyright 2002 TMDA Project http://www.tmda.net/"""
        print abouttxt
        about = Toplevel()
        about.title("About %s" % self.AppName)
        f = Frame(about, bd=15, relief=FLAT)
        f.pack(side=TOP, fill=BOTH, expand=1)
        about.txt = Label(f, text=abouttxt, relief=GROOVE, padx=15, pady=15)
        about.txt.pack(side=TOP, fill=BOTH, expand=1)
        f = Frame(about, bd=10, relief=FLAT)
        f.pack(side=TOP, fill=BOTH, expand=1)
        about.ok = Button(f, text="OK", command=about.destroy, relief=GROOVE)
        about.ok.pack(side=TOP)
    
    def createMenu(self):
        self.menu = Frame(self, relief=RAISED, bd=1)
        self.menu.pack(side=TOP, fill=X)
        self.menu.buttons = [] 
        for button in self.menudef:
            m = Menubutton(self.menu, button[0])
            m.pack(side=LEFT, padx="2m")
            m.menu = Menu(m)
            for cmd in button[1:]:
                m.menu.add_command(cmd)
            m['menu'] = m.menu
            self.menu.buttons.append(m)

    def MessageRefresh(self, ev=None):
        self.message.text.delete(1.0, END)
        self.listbox.Refresh()
        self.updateStatus()

    def MessageShow(self, ev=None):
        self.message.text.delete(1.0, END)
        (hdr, bdy) = self.listbox.GetSelectedMsgContent()
        self.message.text.tag_configure('header', font=('Courier', 10, 'bold'),
                                        foreground='blue', background='#CCCCCC')
        self.message.text.tag_configure('body', font=('Courier', 10))
        self.message.text.insert(END, hdr+'\n', ('header',))
        self.message.text.insert(END, '\n'+bdy, ('body',))

    def MessageWhitelist(self, ev=None):
        self.MessageShow()
        self.listbox.WhitelistSelectedMessage()

    def MessageBlacklist(self, ev=None):
        self.MessageShow()
        self.listbox.BlacklistSelectedMessage()

    def MessageRelease(self, ev=None):
        self.message.text.delete(1.0, END)
        self.listbox.ReleaseSelectedMessage()
        self.updateStatus()

    def MessageDelete(self, ev=None):
        self.message.text.delete(1.0, END)
        self.listbox.DeleteSelectedMessage()
        self.updateStatus()

    def createWidgets(self):
        #self.createMenu()

        self.toolbar = Frame(self, relief=GROOVE)

        b = Button(self.toolbar, text="Refresh", bd=1,
                   command=self.MessageRefresh)
        b.pack(side=LEFT, padx=0, pady=0)
        b = Button(self.toolbar, text="Show", bd=1,
                   command=self.MessageShow)
        b.pack(side=LEFT, padx=0, pady=0)
        b = Button(self.toolbar, text="Whitelist", bd=1,
                   command=self.MessageWhitelist)
        b.pack(side=LEFT, padx=0, pady=0)
        b = Button(self.toolbar, text="Release", bd=1,
                   command=self.MessageRelease)
        b.pack(side=LEFT, padx=0, pady=0)
        b = Button(self.toolbar, text="Blacklist", bd=1,
                   command=self.MessageBlacklist)
        b.pack(side=LEFT, padx=0, pady=0)
        b = Button(self.toolbar, text="Delete", bd=1,
                   command=self.MessageDelete)
        b.pack(side=LEFT, padx=0, pady=0)
#        b = Button(self.toolbar, text="Quit", bd=1,
#                   command=self.FileQuit)
#        b.pack(side=RIGHT, padx=0, pady=0)
        self.toolbar.pack(side=TOP, fill=X)
        
        self.split = HMultiSplitter(self, 2, width=600, height=400,
                                    relief=GROOVE)

        self.split.one = self.split.frames[0]
        self.split.two = self.split.frames[1]
    
        self.split.pack(fill=BOTH, expand=YES)

        if not self.statusbar:
            self.statusbar = StatusBar(self)
            self.statusbar.pack(side=BOTTOM, fill=X)

        self.listbox = MessageList(self.split.one, statusbar=self.statusbar)
        self.listbox.bind("<Double-Button-1>", self.MessageShow)
        self.listbox.pack(fill=BOTH, expand=YES)

        self.message = self.split.two
        self.message.text = Text(self.message, bd=1, relief=GROOVE)#, anchor=W)
        scrollbar = Scrollbar(self.message, orient=VERTICAL)
        self.message.text.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.message.text.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        self.message.text.scrollbar=scrollbar
        self.message.text.bind('<Key>', lambda ev: 'break')
        self.message.text.pack(fill=BOTH, expand=YES)


    def updateStatus(self, ev=None):
        self.statusbar.Set("%d messages in pending queue..." \
                                    % len(self.listbox.msgs))

    def poll(self):
        self.counter += 1
        if self.counter > self.refresh_interval:
            self.counter = 0
            self.MessageRefresh()
        self.master.after(1000, self.poll)


class AddressGUI(Frame):
    def __init__(self, master=None, **args):
        R = 0
        Frame.__init__(self, master, args)

        R += 1
        Label(self, text="Keyword:").grid(row=R, sticky=W)
        self.e_keyword = Entry(self)
        self.e_keyword.grid(row=R, column=1, sticky=W)
        self.r_keyword = Entry(self, state=DISABLED)
        self.r_keyword.grid(row=R, column=2, sticky=NW)
        
        R += 1
        Label(self, text="Sender:").grid(row=R, sticky=W)
        self.e_sender = Entry(self)
        self.e_sender.grid(row=R, column=1, sticky=W)
        self.r_sender = Entry(self, state=DISABLED)
        self.r_sender.grid(row=R, column=2, sticky=NW)
        
        R += 1
        Label(self, text="Dated:").grid(row=R, sticky=NW)
        f = Frame(self)
        f.grid(row=R, column=1, sticky=NW)
        self.e_dated = Entry(f, width=4)
        self.e_dated.insert(END, "5")
        self.e_dated.grid(row=0, column=0, sticky=NW)

        self.units = [
            ("years",  "Y"),
            ("months", "M"),
            ("weeks",  "w"),
            ("days",   "d"),
            ("hours",  "h"),
            ("mins",   "i"),
            ("secs",   "s"),
        ]
        self.uidx = 3 # default to days
        self.e_dated_unit = StringVar()
        self.e_dated_unit.set('d')

        f = Frame(f)
        f.grid(row=0, column=1)
        self.m_du = Button(f, text=self.units[self.uidx][0], relief=RAISED, command=self.LClick)
        self.m_du.bind('<Button-3>', self.RClick)
        self.m_du.pack(fill=BOTH, expand=1)

        self.r_dated = Entry(self, state=DISABLED)
        self.r_dated.grid(row=R, column=2, sticky=NW)
        
        R += 1
        f = Frame(self)
        f.grid(row=R, columnspan=3)
        Button(f, text="Create / Check Address", command=self.Calc).grid(row=0, column=0, columnspan=3)

        R += 1
        Label(self, text="Check:").grid(row=R, sticky=W)
        self.e_check = Entry(self)
        self.e_check.grid(row=R, column=1, sticky=NW)
        self.e_check_sa = Entry(self)
        self.e_check_sa.grid(row=R, column=2, sticky=NW)
        R += 1
        self.r_check = Label(self, text="Enter an address to check")
        self.r_check.grid(row=R, column=1, columnspan=2, sticky=NW)
        
        self.Calc()

    def RClick(self, ev=None):
        self.uidx = (len(self.units) + self.uidx - 1) % len(self.units)
        self.m_du.configure(text=self.units[self.uidx][0])

    def LClick(self, ev=None):
        self.uidx = (len(self.units) + self.uidx + 1) % len(self.units)
        self.m_du.configure(text=self.units[self.uidx][0])

    def Calc(self, ev=None):
        self.r_dated['state'] = NORMAL
        self.r_dated.delete(0, END)
        date = self.e_dated.get().strip()
        if date:
            self.r_dated.insert(END, getAddress('dated', date + self.units[self.uidx][1]))
        self.r_dated['state'] = DISABLED

        self.r_keyword['state'] = NORMAL
        self.r_keyword.delete(0, END)
        keyword = self.e_keyword.get().strip()
        if keyword:
            self.r_keyword.insert(END, getAddress('keyword', keyword))
        self.r_keyword['state'] = DISABLED

        self.r_sender['state'] = NORMAL
        self.r_sender.delete(0, END)
        sender = self.e_sender.get().strip()
        if sender:
            self.r_sender.insert(END, getAddress('sender', sender))
        self.r_sender['state'] = DISABLED

        tagged_addr = self.e_check.get().strip()
        if tagged_addr:
            sender_addr = self.e_check_sa.get().strip()
            if not sender_addr:
                sender_addr = None
            status = checkAddress(tagged_addr, sender_addr)
        else:
            status = "Enter an address to check"
        self.r_check.configure(text=status)

class About(Frame):
    def __init__(self, master, AppName, **args):
        if not master:
            master = Toplevel()
        Frame.__init__(self, master, args)

        abouttxt = """Copyright 2002 David Guerizec <david@guerizec.net>\n""" + \
                   """Copyright 2002 TMDA Project http://www.tmda.net/"""
        print abouttxt
        try:
            self.title("About %s" % AppName)
            self.ok = Button(f, text="OK", command=self.destroy, relief=GROOVE)
            self.ok.pack(side=TOP)
        except AttributeError:
            pass
        f = Frame(self, bd=15, relief=FLAT)
        f.pack(side=TOP, fill=BOTH, expand=1)
        self.txt = Label(f, text=abouttxt, relief=GROOVE, padx=15, pady=15)
        self.txt.pack(side=TOP, fill=BOTH, expand=1)
        f = Frame(self, bd=10, relief=FLAT)
        f.pack(side=TOP, fill=BOTH, expand=1)
        

class TMDAGUI(Frame):
    AppName = "tmda-gui"
    def __init__(self, master=None, **args):
        if master:
            master.title(self.AppName)
            master.protocol("WM_DELETE_WINDOW", self.Quit)
        self.master = master
        Frame.__init__(self, master, args)
        self.tabs = Frame(master=self)
        self.tabs.pack(side=TOP, fill=X)
        self.baddress = Button(self.tabs, text='Address', command=self.displayAddress)
        self.baddress.pack(side=LEFT)
        self.bpending = Button(self.tabs, text='Pending', command=self.displayPending)
        self.bpending.pack(side=LEFT)
        self.bquit = Button(self.tabs, text='Quit', command=self.Quit)
        self.bquit.pack(side=RIGHT)
        self.babout = Button(self.tabs, text='About', command=self.displayAbout)
        self.babout.pack(side=RIGHT)
        self.statusbar = StatusBar(self)
        self.statusbar.pack(side=BOTTOM, fill=X)
        self.displayAddress()
        
    def displayAddress(self):
        try:
            self.panel.destroy()
        except AttributeError:
            pass
        self.statusbar.Set('Tagged address center')
        self.panel = AddressGUI(master=self)
        self.panel.pack(fill=BOTH, expand=YES)
        self.statusbar.progress.Hide()

    def displayPending(self):
        try:
            self.panel.destroy()
        except AttributeError:
            pass
        self.bpending.update()
        self.statusbar.Set('Pending messages center')
        self.panel = PendingGUI(master=self, statusbar=self.statusbar)
        self.panel.pack(fill=BOTH, expand=YES)
        self.statusbar.progress.Hide()

    def displayAbout(self):
        try:
            self.panel.destroy()
        except AttributeError:
            pass
        self.statusbar.Set('Welcome to a SPAM free world!', anchor=CENTER)
        self.panel = About(master=self, AppName=self.AppName)
        self.panel.pack(fill=BOTH, expand=YES)
        self.statusbar.progress.Hide()

    def Quit(self):
        self.master.destroy()

def main():
    root = Tk()
    if using_network:
        r = connectToServer(host=(host, port), auth=(user, passwd))
        if not r:
            raise
    if pending_first:
        PendingGUI(root).pack(fill=BOTH, expand=YES)
    else:
        TMDAGUI(root, width=800, height=600).pack(fill=BOTH, expand=YES)
    root.mainloop()

if __name__ == '__main__':
    main()
