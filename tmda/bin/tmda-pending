#!/usr/bin/env python
#
# Copyright (C) 2001,2002 Jason R. Mastaler <jason@mastaler.com>
#
# This file is part of TMDA.
#
# TMDA is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  A copy of this license should
# be included in the file COPYING.
#
# TMDA is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with TMDA; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

"""Pending queue manipulation tool.

Usage:  %(program)s [OPTIONS] [messages ... | - ]

Where:
    -c <file>
    --config-file <file>
       Specify a different configuration file other than ~/.tmdarc.

    -i
    --interactive
       Display a summary of each pending message and prompt for
       disposal (pass, show, release, delete, quit).  Implies
       --verbose.  (default)

    -p
    --pretend
       Don't actually operate on messages, just show what would have happened.
       Implies --verbose.

    -b
    --batch
       Operate non-interactively.  Use with caution.
       
    -r
    --release
       Release messages.

    -d
    --delete
       Delete messages.

    -s
    --summary
       Print a summary of pending messages along with a release address link.
       Implies --verbose.

    -T
    --terse-summary
       Print a terse (one-line per message) summary of pending messages.
       Customize display with TERSE_SUMMARY_HEADERS in the tmdarc.
       Implies --verbose.
       
    -S
    --show
       Display the full contents of the given message with $PAGER (usually
       the `more', or `less' program).
       
    -C
    --cache
       Operate only on messages which aren't stored in .msgcache (i.e,
       haven't yet been seen).  After operation, store the message in
       .msgcache.  Useful primarily in conjunction with the --summary
       option.
       
    -A
    --ascending
       Operate on messages in ascending order (default).

    -D
    --descending
       Operate on messages in descending order.
      
    -R <user@host>
    --recipient <user@host>
       Override the address used to create the magic release address.
       Normally, this is determined by parsing the `X-TMDA-Recipient'
       header which every pending message should contain.

    -Y <interval>
    --younger <interval>
       Operate only on messages younger than the time interval given in
       seconds (s), minutes (m), hours (h), days (d), weeks (w), months
       (M), or years (Y).

    -O <interval>
    --older <interval>
       Operate only on messages older than the time interval given in
       seconds (s), minutes (m), hours (h), days (d), weeks (w), months
       (M), or years (Y).

    -v
    --verbose
       Display output (default).

    -q
    --quiet
       Suppress output.  Not compatible with --interactive.

    -V
    --version
       Print TMDA version information and exit.
 
    -h
    --help
       Print this help message and exit.

    messages | -
       If one or more messages are provided, operate just on them. 
       If `-' is specified, operate on a list of messages provided by
       standard input. Otherwise, operate on all messages in the pending queue.
       
    Examples:

    (interactively operate on all pending messages)
    %(program)s 

    (interactively operate on just these messages)
    %(program)s 1012182077.5803.msg 1012939546.7870.msg

    (immediately release these messages from the pending queue)
    %(program)s -b -r 1012182077.5803.msg 1012939546.7870.msg

    (immediately release any messages with `foobar' in them)
    %(program)s -b -T | grep foobar | awk '{print $1}' | %(program)s -b -r -

    (immediately delete all messages from the pending queue)
    %(program)s -b -d

    (silently and immediately delete all messages older than 30 days)
    %(program)s -q -b -d -O 30d
    
    (mail a summary report of all new pending messages)
    %(program)s -C -b -s | mail -s 'TMDA pending summary' jason
"""

import getopt
import glob
import os
import sys
import time

try:
    import paths
except ImportError:
    # Prepend /usr/lib/python2.x/site-packages/TMDA/pythonlib
    sitedir = os.path.join(sys.prefix, 'lib', 'python'+sys.version[:3],
                           'site-packages', 'TMDA', 'pythonlib')
    sys.path.insert(0, sitedir)

import email

from TMDA import Version


program = sys.argv[0]
# Defaults
cache = None
command_recipient = None
descending = None
dispose = None
interactive = 1
older = None
pretend = None
summary = None
terse = None
threshold = None
verbose = 1
younger = None


def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)

try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'c:ipbrdsTSCADR:Y:O:vqVh', ['config-file=',
                                                           'interactive',
                                                           'pretend',
                                                           'batch',
                                                           'release',
                                                           'delete',
                                                           'summary',
                                                           'terse-summary',
                                                           'show',
                                                           'cache',
                                                           'ascending',
                                                           'descending',
                                                           'recipient=',
                                                           'younger=',
                                                           'older=',
                                                           'verbose',
                                                           'quiet',
                                                           'version',
                                                           'help'])
except getopt.error, msg:
    usage(1, msg)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage(0)
    if opt == '-V':
        print Version.ALL
        sys.exit()
    if opt == '--version':
        print Version.TMDA
        sys.exit()
    elif opt in ('-c', '--config-file'):
        os.environ['TMDARC'] = arg
    elif opt in ('-i', '--interactive'):
        interactive = verbose = 1
    elif opt in ('-p', '--pretend'):
        pretend = verbose = 1
    elif opt in ('-b', '--batch'):
        interactive = 0
    elif opt in ('-r', '--release'):
        dispose = 'release'
    elif opt in ('-d', '--delete'):
        dispose = 'delete'
    elif opt in ('-s', '--summary'):
        summary = 1
    elif opt in ('-T', '--terse-summary'):
        terse = 1
    elif opt in ('-S', '--show'):
        dispose = 'show'
    elif opt in ('-C', '--cache'):
        cache = 1
    elif opt in ('-A', '--ascending'):
        descending = 0
    elif opt in ('-D', '--descending'):
        descending = 1
    elif opt in ('-R', '--recipient'):
        command_recipient = arg
    elif opt in ('-Y', '--younger'):
        younger = 1
        threshold = arg
    elif opt in ('-O', '--older'):
        older = 1
        threshold = arg
    elif opt in ('-q', '--quiet'):
        verbose = 0
    elif opt in ('-v', '--verbose'):
        verbose = 1


from TMDA import Cookie
from TMDA import Defaults
from TMDA import Util


def cprint(verbose=1, *strings):
    """Conditionally print one or more strings."""
    if verbose:
        for s in strings:
            print s,
        print
    else:
        return


def confirm_accept_address(recipient, msg):
    (timestamp, pid, suffix) = msg.split('.')
    return Cookie.make_confirm_address(recipient, timestamp, pid, 'accept')


def release(msgobj, msg):
    """Release a message from the pending queue."""
    timestamp, pid, suffix = msg.split('.')
    # Remove Return-Path: to avoid duplicates.
    return_path = email.Utils.parseaddr(msgobj.get('return-path'))[1]
    del msgobj['return-path']
    # Remove X-TMDA-Recipient:
    recipient = msgobj.get('x-tmda-recipient')
    del msgobj['x-tmda-recipient']
    # To avoid a mail loop on re-injection, prepend an ``Old-'' prefix
    # to all existing Delivered-To lines.
    Util.rename_headers(msgobj, 'Delivered-To', 'Old-Delivered-To')
    # Add an X-TMDA-Confirm-Done: field to the top of the header for
    # later verification.  This includes a timestamp, pid, and HMAC.
    del msgobj['X-TMDA-Confirm-Done']
    msgobj['X-TMDA-Confirm-Done'] = Cookie.make_confirm_cookie(timestamp,
                                                               pid, 'done')
    # Add the date when confirmed in a header.
    del msgobj['X-TMDA-Released']
    msgobj['X-TMDA-Released'] = Util.unixdate()
    # Reinject the message to the original envelope recipient.
    Util.sendmail(msgobj.as_string(), recipient, return_path)


def main():
    global cache
    global command_recipient
    global descending
    global dispose
    global interactive
    global older
    global summary
    global terse
    global threshold
    global verbose
    global younger
    

    pendingdir = os.path.join(Defaults.DATADIR, 'pending')
    if os.path.exists(pendingdir):
        os.chdir(pendingdir)
    else:
        print '%s does not exist, exiting.' % pendingdir

    msgs = args

    # Replace any `-' in the message list with those messages provided
    # via standard input.  (Since it's pointless to call it twice,
    # it's safe to remove any subsequent occurrences in the list after
    # processing.)
    wantedstdin = 0
    for msg in msgs:
        if msg == '-':
            wantedstdin = 1
            for line in sys.stdin.readlines():
                msgs.append(line.strip())
            msgs.remove('-')

    if not msgs and not wantedstdin:
        msgs = glob.glob('*.*.msg')

    msgs.sort()
    if descending:
        msgs.reverse()
    total = len(msgs)
    count = 0
    
    if dispose is None:
        dispose_def = 'pass'
    else:
        dispose_def = dispose

    if os.path.exists(Defaults.DELIVERED_CACHE):
        delcache = Util.unpickle(Defaults.DELIVERED_CACHE)
    else:
        delcache = []
    if cache:
        if os.path.exists(Defaults.PENDING_CACHE):
            msgcache = Util.unpickle(Defaults.PENDING_CACHE)
        else:
            msgcache = []
        
    for msg in msgs:
        count = count + 1
        if not os.path.exists(msg):
            cprint(verbose, msg, 'not found!')
        else:
            delivered = None
            for dict in delcache:
                if dict.has_key(msg):
                    delivered = 1
                    break
            if delivered:
                if dispose == 'delete' and not interactive:
                    # continue if we are running in batch/delete mode,
                    # else delivered messages will never be removed
                    # from disk
                    pass
                else:
                    # skip delivered messages
                    continue
            if threshold:
                threshold_secs = Util.seconds(threshold)
                now = '%d' % time.time()
                min_time = int(now) - int(threshold_secs)
                msg_time = int(msg.split('.')[0])
                if (younger and msg_time < min_time) or \
                   (older and msg_time > min_time):
                    # skip this message
                    continue
            if cache:
                if msg in msgcache:
                    # skip this message
                    continue
                else:
                    msgcache.insert(0, msg)
            msgobj = email.message_from_file(open(msg, 'r'))
            msg_size = len(msgobj.as_string())
            bytes = 'bytes'
            if msg_size == 1:
                bytes = bytes[:-1]
            recipient_address = command_recipient
            if not recipient_address:
                recipient_address = msgobj.get('x-tmda-recipient')
            # Pass over the message if it lacks X-TMDA-Recipient and we
            # aren't using `-R'.
            if not recipient_address:
                cprint(verbose,
                       "can't determine recipient address, skipping", msg)
                continue
            if summary or interactive and not terse:
                print
                print msg, "(%s of %s / %s %s)" % (count,
                                                   total,
                                                   msg_size,
                                                   bytes)
                for hdr in Defaults.SUMMARY_HEADERS:
                    print "%s %s: %s" % ('  >>',
                                         hdr.capitalize()[:4].rjust(4),
                                         Util.decode_header(msgobj.get(hdr)))
                if summary:
                    print '<mailto:%s>' % (confirm_accept_address
                                           (recipient_address, msg))
            if terse:
                if interactive:
                    print
                terse_hdrs = []
                for hdr in Defaults.TERSE_SUMMARY_HEADERS:
                    if hdr in ('from_name', 'from_address'):
                        from_name, from_address = email.Utils.parseaddr(msgobj.get
                                                                        ('from'))
                        if hdr == 'from_name':
                            terse_hdrs.append(from_name
                                              or from_address or 'None')
                        elif hdr == 'from_address':
                            terse_hdrs.append(from_address or 'None')
                    else:
                        terse_hdrs.append(msgobj.get(hdr))
                terse_hdrs.insert(0, msg)
                print '\t'.join([Util.decode_header(hdr) for hdr in terse_hdrs])
            if interactive:
                try:
		    message = '([p]ass / [s]how / [r]el / [d]el'
                    if Defaults.PENDING_WHITELIST_APPEND:
			message = message + ' / [w]hite'
                    if Defaults.PENDING_BLACKLIST_APPEND:
			message = message + ' / [b]lack'
		    message = message + ' / [q]uit) [%s]: '
                    inp = raw_input(message % dispose_def)
                    ans = inp[0:1].lower()
                    if ans == "":
                        dispose = dispose_def
                    elif ans == "p":
                        dispose = 'pass'
                    elif ans == "s":
                        dispose = 'show'
                    elif ans == "r":
                        dispose = 'release'
                    elif ans == 'd':
                        dispose = 'delete'
                    elif ans == 'w' and Defaults.PENDING_WHITELIST_APPEND:
                        dispose = 'whitelist'
                    elif ans == 'b' and Defaults.PENDING_BLACKLIST_APPEND:
                        dispose = 'blacklist'
                    elif ans == "q":
                        break
                    else:
                        print '\n', "I don't understand %s" % (`inp`)
                        dispose = 'pass'
                except KeyboardInterrupt:
                    print
                    break
            # Optionally dispose of the message
            message = '%s %s' % (dispose, msg)
            if pretend:
                message = message + ' (not)'
            if dispose:
                cprint(verbose, '\n', message)
            if not pretend:
                if dispose in ('release', 'delete', 'whitelist', 'blacklist'):
                    return_path = email.Utils.parseaddr(msgobj.get('return-path'))[1]
                if dispose == 'release':
                    if Defaults.PENDING_RELEASE_APPEND:
                        Util.append_to_file(return_path,
                                            Defaults.PENDING_RELEASE_APPEND)
                    release(msgobj, msg)
                elif dispose == 'delete':
                    if Defaults.PENDING_DELETE_APPEND:
                        Util.append_to_file(return_path,
                                            Defaults.PENDING_DELETE_APPEND)
                    os.unlink(msg)
		elif dispose == 'whitelist':
                    if Defaults.PENDING_WHITELIST_APPEND:
                        Util.append_to_file(return_path,
                                            Defaults.PENDING_WHITELIST_APPEND)
		elif dispose == 'blacklist':
                    if Defaults.PENDING_BLACKLIST_APPEND:
                        Util.append_to_file(return_path,
                                            Defaults.PENDING_BLACKLIST_APPEND)
                elif dispose == 'pass':
                    continue
                elif dispose == 'show':
                    Util.pager(msg)
                if interactive and dispose in ('show', 'whitelist', 'blacklist'):
                    count = count - 1
                    msgs.insert(msgs.index(msg), msg)
                    if cache:
                        # remove message from cache, or else we
                        # won't be prompted for it again
                        msgcache.remove(msg)
                        
    if cache:
        # Trim tail entries off if necessary, and then save the cache.
        msgcache = msgcache[:Defaults.PENDING_CACHE_LEN]
        Util.pickleit(msgcache, Defaults.PENDING_CACHE)


# This is the end my friend.
if __name__ == '__main__':
    main()
