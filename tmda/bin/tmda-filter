#!/usr/bin/env python

########################
# Delivery (server) mode
########################

"""Filter incoming messages on standard input.

Usage:  %(program)s [-c <file>] [-d] [-D <file>] [-S <file>] [-h]

Where:
	-c <file>
	--config-file <file>
	   Specify a different configuration file other than ~/.tmdarc.
	   
	-d
	--discard
	   Discard message if address is invalid instead of bouncing it.

	-D
	--dated-template <file>
	   Specify the full pathname to a custom template for 'dated' bounces.

        -S
	--sender-template <file>
	   Specify the full pathname to a custom template for 'sender' bounces.

	--help
	-h
	   Print this help message and exit.
"""

import cStringIO
import getopt
import fileinput
import os
import popen2
import re
import rfc822
import stat
import string
import sys
import time


discard = None
program = sys.argv[0]

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)
    
try:
    opts, args = getopt.getopt(sys.argv[1:],
                                   'c:dD:S:h', ['config-file=',
                                                'discard',
                                                'dated-template=',
                                                'sender-template=',
                                                'help'])
except getopt.error, msg:
    usage(1, msg)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage(0)
    elif opt in ('-S', '--sender-template'):
        os.environ['TMDA_SENDER_TEMPLATE'] = arg
    elif opt in ('-D', '--dated-template'):
        os.environ['TMDA_DATED_TEMPLATE'] = arg
    elif opt in ('-d', '--discard'):
	discard = 1
    elif opt in ('-c', '--config-file'):
        os.environ['TMDARC'] = arg
    

import paths
from TMDA import Cookie
from TMDA import Defaults
from TMDA import Util


# Read sys.stdin into a temporary variable for later access.
stdin = cStringIO.StringIO(sys.stdin.read())

# Collect the message headers.
message_headers = rfc822.Message(stdin)

# Collect the entire message.
message = stdin.getvalue()
# Calculate the message size.
message_size = str(len(stdin.read()))

# $SENDER is the envelope sender address.
envelope_sender = os.environ.get('SENDER')


def logit(action_msg,date):
    """Write delivery statistics to the LOGFILE if enabled."""
    if Defaults.LOGFILE and os.environ.get('RECIPIENT'):
        try:
            logfile = open(Defaults.LOGFILE, 'a') # append to the file
            Date = time.asctime(time.localtime(date))
            From = message_headers.getheader('from')
            if not From:From = envelope_sender
            To = os.environ.get('RECIPIENT')
            Subject = message_headers.getheader('subject', 'None')
            Action = action_msg
            actionstr = 'Actn: ' + Action
            sizestr = '(' + message_size + ')'
            wsbuf = 78 - len(actionstr) - len(sizestr)
            
            # Write the log entry and then close the log.
            logfile.write('Date: ' + Date + '\n')
            logfile.write('From: ' + From + '\n')
            logfile.write('  To: ' + To + '\n')
            logfile.write('Subj: ' + Subject + '\n')
            logfile.write(actionstr + ' '*wsbuf + sizestr + '\n')
            logfile.write('\n')
            logfile.close()

        except IOError, error_msg:
            print error_msg
            sys.exit(Defaults.ERR_IO)


def send_bounce(bounce_message):
    """Send a nice bounce message back to the sender."""
    bounce_message = cStringIO.StringIO(bounce_message)
    message_headers = rfc822.Message(bounce_message)
    # Add headers.
    message_headers['Return-Path'] = '<' + Defaults.BOUNCE_ENV_SENDER + '>'
    message_headers['To'] = envelope_sender
    message_headers['X-Delivery-Agent'] = Defaults.DELIVERY_AGENT
    message_body = bounce_message.read()
    inject = []
    inject.append(Defaults.INJECT)
    inject.append(envelope_sender)
    pipeline = popen2.popen2(inject)[1]
    pipeline.write(str(message_headers))
    pipeline.write('\n')
    pipeline.write(message_body)
    pipeline.write('\n\n--- Below this line is a copy of the message.\n\n')
    pipeline.write(message) # original message with headers
    pipeline.close()
    

def bounce_cc(address):
    """Send a 'carbon copy' of the bounced message to address."""
    inject = Defaults.INJECT + ' ' + address # "qmail-inject recipient"
    pipeline = os.popen(inject, 'w')
    pipeline.write(message)
    pipeline.close()
    logit(inject,time.time())


def verify_dated_cookie(dated_cookie):
    """Verify a dated cookie."""
    # Save some time if the dated_cookie doesn't exist or is bogus.
    if not dated_cookie:
        bounce_dated()
    dated_cookie_split = string.split(dated_cookie,'.')
    if len(dated_cookie_split) != 2:
        bounce_dated()

    cookie_date = dated_cookie_split[0]
    datemac = dated_cookie_split[1]
    newdatemac = Cookie.datemac(cookie_date)

    # Accept the message only if the address has not expired AND the HMAC
    # can be verified.
    now = time.time()
    if ((int(cookie_date) >= int('%d' % now)) and (datemac == newdatemac)):
        logit("OK good_dated_cookie",now)
        sys.exit(Defaults.ERR_OK)
    elif discard:
        sys.exit(Defaults.ERR_STOP)
    else:
        bounce_dated()


def verify_sender_cookie(sender_address,sender_cookie):
    """Verify a sender cookie."""
    sender_address_cookie = Cookie.make_sender_cookie(sender_address)

    # Accept the message only if the HMAC can be verified.
    if (sender_cookie == sender_address_cookie):
        logit("OK good_sender_cookie", time.time())
        sys.exit(Defaults.ERR_OK)
    elif discard:
        sys.exit(Defaults.ERR_STOP)
    else:
        bounce_sender(sender_address,sender_address_cookie)


def bounce_dated():
    """Bounce the message back to sender with a new dated cookie."""
    now = time.time()
    timeout = Util.format_timeout(Defaults.TIMEOUT)
    expire_date = now + Util.seconds(Defaults.TIMEOUT)
    expire_utc_tuple = time.gmtime(expire_date)
    utc_expire_date = time.asctime(expire_utc_tuple)
    dated_cookie = Cookie.make_dated_cookie('%d' % now)

    logit("BOUNCE dated",now)

    if Defaults.BOUNCE_DATED_CC:
        bounce_cc(Defaults.BOUNCE_DATED_CC)

    # Create the bounce message from a template.
    TMDA_DATED_TEMPLATE = os.environ.get('TMDA_DATED_TEMPLATE')
    if TMDA_DATED_TEMPLATE and os.path.exists(TMDA_DATED_TEMPLATE):
        bounce_message = Util.maketext(TMDA_DATED_TEMPLATE,vars())
    elif (Defaults.BOUNCE_DATED_TEMPLATE and
          os.path.exists(Defaults.BOUNCE_DATED_TEMPLATE)):
        bounce_message = Util.maketext(Defaults.BOUNCE_DATED_TEMPLATE,vars())
    else:
        # default to ../templates/bounce_dated.txt
        template_dir = os.path.split(os.path.dirname
                                     (os.path.abspath
                                      (sys.argv[0])))[0] + '/templates'
        dt = os.path.join(template_dir, 'bounce_dated.txt')
        bounce_message = Util.maketext(dt,vars())

    send_bounce(bounce_message)
    sys.exit(Defaults.ERR_STOP)


def bounce_sender(sender_address,sender_address_cookie):
    """Bounce the message back to sender with their sender cookie."""
    logit("BOUNCE sender",time.time())

    if Defaults.BOUNCE_SENDER_CC:
        bounce_cc(Defaults.BOUNCE_SENDER_CC)

    # Create the bounce message from a template.
    TMDA_SENDER_TEMPLATE = os.environ.get('TMDA_SENDER_TEMPLATE')
    if TMDA_SENDER_TEMPLATE and os.path.exists(TMDA_SENDER_TEMPLATE):
        bounce_message = Util.maketext(TMDA_SENDER_TEMPLATE,vars())
    elif (Defaults.BOUNCE_SENDER_TEMPLATE and
          os.path.exists(Defaults.BOUNCE_SENDER_TEMPLATE)):
        bounce_message = Util.maketext(Defaults.BOUNCE_SENDER_TEMPLATE,vars())
    else:
        # default to ../templates/bounce_sender.txt
        template_dir = os.path.split(os.path.dirname
                                     (os.path.abspath
                                      (sys.argv[0])))[0] + '/templates'
        st = os.path.join(template_dir, 'bounce_sender.txt')
        bounce_message = Util.maketext(st,vars())
        
    send_bounce(bounce_message)
    sys.exit(Defaults.ERR_STOP)


######
# Main
######

def main():

    # Decide what to do with the incoming message based on environment
    # variables supplied by qmail-local.  See qmail-command(8) for more info.

    # EXT is the address extension, ext.
    ext = os.environ.get('EXT')         
    if ext:ext = string.lower(ext)

    # EXT2 is the portion of EXT following the first dash.
    ext2 = os.environ.get('EXT2') 
    if ext2:ext2 = string.lower(ext2)

    # EXT3 is the portion of EXT following the second dash.
    # This should normally only be defined under a virtualdomain.
    ext3 = os.environ.get('EXT3') 
    if ext3:ext3 = string.lower(ext3)

    # EXT4 is the portion of EXT following the third dash.  This
    # should normally only be defined if a "pre-extension" is defined
    # in /var/qmail/users/assign.
    ext4 = os.environ.get('EXT4') 
    if ext4:ext4 = string.lower(ext4)

    # HOST is the domain part of the recipient address.
    host = os.environ.get('HOST')
    if host:host = string.lower(host)

    # When qmail rewrites a virtualdomain address into a local one, it
    # changes $USER, but not $HOST.  Therefore if $HOST is NOT in
    # control/locals, it's a virtualdomain address.
    localslist = []
    for line in fileinput.input(Defaults.LOCALS):
        localslist.append(string.lower(string.strip(line)))

    # If this is a virtualdomain, shift the EXT* variables once left.
    # (i.e, EXT under normal == EXT2 under a virtualdomain, etc.)
    if host not in localslist:
        ext = ext2
        ext2 = ext3

    # If a "pre-extension" is defined in the users/assign file, it is
    # prepended to the address before being processed.  Set USERPREFIX
    # to match the "pre-extension" so we can look for it and shift if
    # off.
    if Defaults.USERPREFIX:
        prefix=ext[:string.find(ext,ext2)-1]
        if prefix == Defaults.USERPREFIX:
            # Shift the EXT* variables twice left.
            ext = ext2
            ext2 = ext3
            ext3 = ext4
            
    # Extract the e-mail address from From:, and Reply-To:
    From = message_headers.getaddr('from')[1]
    ReplyTo = message_headers.getaddr('reply-to')[1]
    
    while 1:
        # Is the sender in the BLACKLIST?
        if os.path.exists(Defaults.BLACKLIST) and \
           Util.substring_match(Defaults.BLACKLIST,
                                envelope_sender, From, ReplyTo):
            logit("BOUNCE blacklist_match", time.time())
            if Defaults.BOUNCE_BLACKLIST_CC:
                bounce_cc(Defaults.BOUNCE_BLACKLIST_CC)
            print "Sorry, your address matches my blacklist."
            sys.exit(Defaults.ERR_HARD)
        # Is the sender in the WHITELIST?
        elif os.path.exists(Defaults.WHITELIST) and \
             Util.substring_match(Defaults.WHITELIST,
                                  envelope_sender, From, ReplyTo):
            logit("OK whitelist_match", time.time())
            sys.exit(Defaults.ERR_OK)
        # Dated tag?
        elif ext and (ext == 'dated' or re.match("^dated-\w+",ext)):
            dated_cookie = ext2
            verify_dated_cookie(dated_cookie)
        # Sender tag?
        elif ext and (ext == 'sender' or re.match("^sender-\w+",ext)):
            sender_cookie = ext2
            sender_address = os.environ.get('SENDER')
            verify_sender_cookie(sender_address,sender_cookie)
        # They get the default tag.
        else:
            if Defaults.COOKIE_TYPE == 'dated':
                ext = 'dated'
            elif Defaults.COOKIE_TYPE == 'sender':
                ext = 'sender'
            elif Defaults.COOKIE_TYPE == 'bare':
                logit("OK bare", time.time())
                sys.exit(Defaults.ERR_OK)
            else:
                print "unknown cookie type"
                sys.exit(Defaults.ERR_CONFIG)


# This is the end my friend.
if __name__ == '__main__':
    main()
