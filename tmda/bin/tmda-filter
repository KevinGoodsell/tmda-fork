#!/usr/bin/env python

########################
# Delivery (server) mode
########################

"""Filter incoming messages on standard input.

Usage:  %(program)s [-c <file>] [-h]

Where:
	-c <file>
	--config-file <file>
	   Specify a different configuration file other than ~/.tmdarc.

	--help
	-h
	   Print this help message and exit.
"""

import cStringIO
import getopt
import os
import pwd
import re
import rfc822
import stat
import string
import sys
import time


program = sys.argv[0]

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)
    
try:
    opts, args = getopt.getopt(sys.argv[1:],
                                   'c:h', ['config-file=','help'])
except getopt.error, msg:
    usage(1, msg)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage(0)
    elif opt in ('-c', '--config-file'):
        os.environ['TMDARC'] = arg


import paths
from TMDA import Cookie
from TMDA import Defaults
from TMDA import Greylist
from TMDA import Util


# Read sys.stdin into a temporary variable for later access.
stdin = cStringIO.StringIO(sys.stdin.read())

# Collect the message headers.
message_headers = rfc822.Message(stdin)

# Collect the entire message.
message = stdin.getvalue()
# Calculate the message size.
message_size = str(len(stdin.read()))

def logit(action_msg,date):
    """Write delivery statistics to the LOGFILE if enabled."""
    if Defaults.LOGFILE and os.environ.get('RECIPIENT'):
        try:
            logfile = open(Defaults.LOGFILE, 'a') # append to the file
            Date = time.asctime(time.localtime(date))
            From = message_headers.getheader('from')
            if not From:From = os.environ.get('SENDER')
            To = os.environ.get('RECIPIENT')
            Subject = message_headers.getheader('subject', 'None')
            Action = action_msg
            actionstr = 'Actn: ' + Action
            sizestr = '(' + message_size + ')'
            wsbuf = 78 - len(actionstr) - len(sizestr)
            
            # Write the log entry and then close the log.
            logfile.write('Date: ' + Date + '\n')
            logfile.write('From: ' + From + '\n')
            logfile.write('  To: ' + To + '\n')
            logfile.write('Subj: ' + Subject + '\n')
            logfile.write(actionstr + ' '*wsbuf + sizestr + '\n')
            logfile.write('\n')
            logfile.close()

        except IOError, error_msg:
            print error_msg
            sys.exit(Defaults.ERR_IO)


def bounce_cc(address):
    """Send a 'carbon copy' of the bounced message to address."""
    inject = Defaults.INJECT + ' ' + address # "qmail-inject recipient"
    pipeline = os.popen(inject, 'w')
    pipeline.write(message)
    pipeline.close()
    logit(inject,time.time())


def verify_dated_cookie(dated_cookie):
    """Verify a dated cookie."""
    # Save some time if the dated_cookie doesn't exist or is bogus.
    if not dated_cookie:
        bounce_dated()
    dated_cookie_split = string.split(dated_cookie,'.')
    if len(dated_cookie_split) != 2:
        bounce_dated()

    cookie_date = dated_cookie_split[0]
    datemac = dated_cookie_split[1]
    newdatemac = Cookie.datemac(cookie_date)

    # Accept the message only if the address has not expired AND the HMAC
    # can be verified.
    now = time.time()
    if ((int(cookie_date) >= int('%d' % now)) and (datemac == newdatemac)):
        logit("OK good_dated_cookie",now)
        sys.exit(Defaults.ERR_OK)
    else:
        bounce_dated()


def verify_sender_cookie(sender_address,sender_cookie):
    """Verify a sender cookie."""
    sender_address_cookie = Cookie.make_sender_cookie(sender_address)

    # Accept the message only if the HMAC can be verified.
    if (sender_cookie == sender_address_cookie):
        logit("OK good_sender_cookie", time.time())
        sys.exit(Defaults.ERR_OK)
    else:
        bounce_sender(sender_address,sender_address_cookie)


def bounce_dated():
    """Bounce the message back to sender with a new dated cookie."""
    now = time.time()
    expire_date = now + Util.seconds(Defaults.TIMEOUT)
    expire_utc_tuple = time.gmtime(expire_date)
    dated_cookie = Cookie.make_dated_cookie('%d' % now)
    bounce_message = make_dated_bounce(expire_utc_tuple,dated_cookie)
    logit("BOUNCE dated",now)

    if Defaults.BOUNCE_DATED_CC:
        bounce_cc(Defaults.BOUNCE_DATED_CC)
    
    print bounce_message
    sys.exit(Defaults.ERR_HARD)


def bounce_sender(sender_address,sender_address_cookie):
    """Bounce the message back to sender with their sender cookie."""
    bounce_message = make_sender_bounce(sender_address,sender_address_cookie)
    logit("BOUNCE sender",time.time())

    if Defaults.BOUNCE_SENDER_CC:
        bounce_cc(Defaults.BOUNCE_SENDER_CC)

    print bounce_message
    sys.exit(Defaults.ERR_HARD)


def make_dated_bounce(expire_utc_tuple,dated_cookie):
    """Create a 'dated' style nastygram to send back with the bounce."""
    timeout = Util.format_timeout(Defaults.TIMEOUT)
    utc_expire_date = time.asctime(expire_utc_tuple)
    tmda_url = Defaults.TMDA_HOMEPAGE

    nastygram = \
    """                                                                      
    This notice was generated by TMDA v%s %s.
    Your e-mail message was not accepted either because:
    
        1) The recipient didn't recognize your address, OR 
        2) The `dated' address you sent to was invalid or expired.
        
    You can contact me at the following address:
    
        <mailto:%s-dated-%s@%s>
        
    which will expire in %s (%s UTC).
    If you're just sending me SPAM/UCE, buzz off.
                                                                             
    Regards,
    %s"""% (Defaults.TMDA_VERSION, Defaults.TMDA_HOMEPAGE, Defaults.USERNAME,
            dated_cookie,Defaults.HOSTNAME, timeout, utc_expire_date,
            Defaults.FULLNAME)
        
    return nastygram


def make_sender_bounce(sender_address,sender_address_cookie):
    """Create a 'sender' style nastygram to send back with the bounce."""
            
    nastygram = \
    """                                                                      
    This notice was generated by TMDA v%s %s.
    Your e-mail message was not accepted either because:
    
        1) The recipient didn't recognize your address, OR 
        2) The `sender' address you sent to was invalid.
        
    You can contact me at the following address:
    
        <mailto:%s-sender-%s@%s>
        
    which will only work when you are sending me e-mail from:
                                                             
        <%s>
                                                          
    If you're just sending me SPAM/UCE, buzz off.
                                                                             
    Regards.
    %s"""% (Defaults.TMDA_VERSION,Defaults.TMDA_HOMEPAGE, Defaults.USERNAME,
            sender_address_cookie,Defaults.HOSTNAME, sender_address,
            Defaults.FULLNAME)
    
    return nastygram


######
# Main
######

def main():

    # Decide what to do with the incoming message based on environment
    # variables supplied by qmail-local.  See qmail-command(8) for more info.

    # EXT is the address extension, ext.
    ext = os.environ.get('EXT')         
    if ext:ext = string.lower(ext)

    # EXT2 is the portion of EXT following the first dash.
    ext2 = os.environ.get('EXT2') 
    if ext2:ext2 = string.lower(ext2)

    # EXT3 is the portion of EXT following the second dash.
    # This should normally only be defined under a virtualdomain.
    ext3 = os.environ.get('EXT3') 
    if ext3:ext3 = string.lower(ext3)

    # Under a virtualdomain, 'USER' is set to the domain instead of
    # the username, so this is how we test for it.
    user = pwd.getpwuid(os.getuid())[0]
    # If this is a virtualdomain, shift the EXT* variables once left.
    # (i.e, EXT under normal == EXT2 under a virtualdomain, etc.)
    if user != os.environ.get('USER'):
        ext = ext2
        ext2 = ext3
            
    while 1:
        # Is the sender in the BLACKLIST?
        if os.path.exists(Defaults.BLACKLIST) and \
           Greylist.match(message_headers,Defaults.BLACKLIST):
            logit("BOUNCE blacklist_match", time.time())
            if Defaults.BOUNCE_BLACKLIST_CC:
                bounce_cc(Defaults.BOUNCE_BLACKLIST_CC)
            print "Sorry, your address matches my blacklist."
            sys.exit(Defaults.ERR_HARD)
        # Is the sender in the WHITELIST?
        elif os.path.exists(Defaults.WHITELIST) and \
             Greylist.match(message_headers,Defaults.WHITELIST):
            logit("OK whitelist_match", time.time())
            sys.exit(Defaults.ERR_OK)
        # Dated tag?
        elif ext and (ext == 'dated' or re.match("^dated-\w+",ext)):
            dated_cookie = ext2
            verify_dated_cookie(dated_cookie)
        # Sender tag?
        elif ext and (ext == 'sender' or re.match("^sender-\w+",ext)):
            sender_cookie = ext2
            sender_address = os.environ.get('SENDER')
            verify_sender_cookie(sender_address,sender_cookie)
        # They get the default tag.
        else:
            if Defaults.COOKIE_TYPE == 'dated':
                ext = 'dated'
            elif Defaults.COOKIE_TYPE == 'sender':
                ext = 'sender'
            elif Defaults.COOKIE_TYPE == 'bare':
                logit("OK bare", time.time())
                sys.exit(Defaults.ERR_OK)
            else:
                print "unknown cookie type"
                sys.exit(Defaults.ERR_CONFIG)


# This is the end my friend.
if __name__ == '__main__':
    main()
