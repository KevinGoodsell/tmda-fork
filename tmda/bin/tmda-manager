#!/usr/bin/env python
#
# Copyright (C) 2001,2002 Jason R. Mastaler <jason@mastaler.com>
#
# This file is part of TMDA.
#
# TMDA is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  A copy of this license should
# be included in the file COPYING.
#
# TMDA is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with TMDA; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# Based on code from Python's (undocumented) smtpd module
# Copyright (C) 2001,2002 Python Software Foundation.

"""An authenticated ofmip proxy for TMDA.  Tag your outgoing mail through SMTP.

See <URL:http://tmda.net/tmda-ofmipd.html> for complete setup and
usage information.

Usage: %(program)s [OPTIONS]

OPTIONS:
    -h
    --help
        Print this message and exit.

    -V
    --version
        Print TMDA version information and exit.

    -d
    --daemon
        Daemon mode.

    -D
    --debug
        Turn on debugging prints.

    -u <username>
    --username <username>
        The username that this program should run under.  The default
        is to run as the user who starts the program unless that is
        root, in which case an attempt to seteuid user `tofmipd' will be
        made.  Use this option to override these defaults.

    -H <host:port>
    --hostport <host:port>
        The host:port to listen for incoming connections on.  The
        default is FQDN:8025 (i.e, port 8025 on the fully qualified
        domain name for the local host).

    -R proto[://host[:port]]
    --remoteauth proto[://host[:port]][/dn]
        Host to connect to to check username and password.
        - proto can be one of the following:
          `imap' (IMAP4 server)
          'imaps' (IMAP4 server over SSL)
          `pop3' (POP3 server)
          `apop' (POP3 server with APOP authentication)
          `ldap' (LDAP server)
        - host defaults to localhost
        - port defaults to 143 (imap), 993 (imaps), 110 (pop3/apop), 389 (ldap)
        - dn is mandatory for ldap and should contain a `%%s' identifying
          the username
        Examples: -R imaps://myimapserver.net
                  -R pop3://mypopserver.net:2110
                  -R ldap://host.com/cn=%%s,dc=host,dc=com

    -A <program>
    --authprog <program>
        checkpassword compatible command used to check username/password. e.g,
              `-A /usr/sbin/checkpassword-pam -s id --stdin -- /bin/true'
        The program must be able to receive the username/password pair
        on its stdin, and in the following format:
              `username\\0password\\0'

    -a <file>
    --authfile <file>
        Path to the file holding authentication information for this
        proxy.  Default location is /etc/tofmipd if running as
        root/tofmipd, otherwise ~user/.tmda/tofmipd.  Use this option
        to override these defaults.
"""

import getopt
import os
import socket
import sys

try:
    import paths
except ImportError:
    # Prepend /usr/lib/python2.x/site-packages/TMDA/pythonlib
    sitedir = os.path.join(sys.prefix, 'lib', 'python'+sys.version[:3],
                           'site-packages', 'TMDA', 'pythonlib')
    sys.path.insert(0, sitedir)

from TMDA import Util
from TMDA import Auth
from TMDA import Version

# Some defaults
FQDN = socket.getfqdn()
defaultport = 8765
hostport = '%s:%s' % (FQDN, defaultport)
program = sys.argv[0]
daemon_mode = None

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)

try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'H:u:R:A:a:dDVh', ['hostport=',
                                                     'username=',
                                                     'authfile=',
                                                     'remoteauth=',
                                                     'authprog=',
                                                     'daemon',
                                                     'debug',
                                                     'version',
                                                     'help'])
except getopt.error, msg:
    usage(1, msg)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage(0)
    if opt == '-V':
        print Version.ALL
        sys.exit()
    if opt == '--version':
        print Version.TMDA
        sys.exit()
    elif opt in ('-D', '--debug'):
        Auth.DEBUGSTREAM = sys.stderr
    elif opt in ('-d', '--daemon'):
        daemon_mode = 1
    elif opt in ('-H', '--hostport'):
        hostport = arg
    elif opt in ('-u', '--username'):
        username = arg
    elif opt in ('-R', '--remoteauth'):
        Auth.parse_auth_uri(arg)
        Auth.authtype = 'remote'
    elif opt in ('-A', '--authprog'):
        Auth.authprog = arg
        if Auth.authtype != 'remote':
            Auth.authtype = 'prog'
    elif opt in ('-a', '--authfile'):
        Auth.authfile = arg

Auth.security_disclaimer()
Auth.init_auth_method()

import asynchat
import asyncore
import base64
import hmac
import md5
import popen2
import random
import time


# This can be removed eventually.
warning = 'NOTE: This is early alpha software, and not yet meant for general ' + \
          'use. If you decide to use it anyway, please send your comments to ' + \
          'the tmda-workers@tmda.net mailing list, and not tmda-users.'
print 'WARNING:\n'
print Util.wraptext(warning), '\n'

__version__ = Version.TMDA


import readline
from cmd import Cmd

TMDAShellExit = ''

class TMDAShell(Cmd):
    ProtoVer = '0.2'
    def __init__(self, prompt = '+',
                       stdin = sys.stdin,
                       stdout = sys.stdout,
                       stderr = sys.stderr):
        sys.stdin = stdin
        sys.stdout = stdout
        sys.stderr = stderr
        self.prompt = prompt
        self.authenticated = not Auth.running_as_root
        Cmd.__init__(self)

    def Print(self, *strings):
        self.stdout.write(' '.join(strings))
        self.stdout.write('\n')

    def write(self, string):
        self.stdout.write(string)

    def readline(self):
        return self.stdin.readline()

    def outputData(self, data):
        """Output data."""
        if type(data) == str:
            data = data.split('\n')
        d = []
        for line in data:
            for subline in line.split('\n'):
                d.append(subline)
        sys.stdout.write(' ' + '\n '.join(d) + '\n')

    def parseArgs(self, args, shortopts=[], longopts=[]):
        """Parse command line arguments."""
        pargs = []
        import getopt
        for arg in args.split(' '):
            if not arg:
                continue
            pargs.append(arg)
        try:
            opts, args = getopt.getopt(pargs,
                                        shortopts,
                                        longopts)
        except getopt.error, msg:
            self.error(0, "ARG", str(msg))
            return ([], [])
        return (opts, args)

        return pargs

    def mainLoop(self):
        try:
            self.cmdloop('TMDA Manager v%s\nProtocol v%s' % (Version.TMDA, self.ProtoVer))
        except KeyboardInterrupt, msg:
            raise KeyboardInterrupt, msg

    def log(self, *strings):
        for s in strings:
            sys.stderr.write(str(s))
        sys.stderr.write('\n')

    def error(self, ret, code, str):
        """Output an error message."""
        print "-%s: %s" % (code, str.replace('\n', ' '))
        return ret

    ## Cmd functions
    def do_help(self, args):
        print "Write me!"

    def do_nop(self, args):
        """No-OPeration, do nothing but echo args."""
        self.outputData(args)

    def help_auth(self):
        print "Write me!"

    def do_auth(self, args):
        """Authenticate."""
        if self.authenticated:
            return self.error(0, "AUTH", "Already authenticated.")
        (opts, args) = self.parseArgs(args)
        try:
            self.userid = args[0]
            self.password = args[1]
        except IndexError:
            self.userid = None
            self.password = None
            return self.error(0, "ARG", "Missing argument.")
        if Auth.authenticate_plain(self.userid, self.password):
            self.authenticated = 1
        else:
            self.authenticated = 0
            return self.error(0, "AUTH", "Invalid credentials.")
        if Auth.auth_fork(self.userid):
            sys.exit(0)

        return 0

    def help_checkaddress(self):
        print "Write me!"

    def do_checkaddress(self, args):
        """Check a tagged address."""
        if not self.authenticated:
            return self.error(0, "AUTH", "Please authenticate first.")
        (opts, args) = self.parseArgs(args, 'l', [ 'localtime' ] )

        from TMDA import Address

        try:
            opts[0][0]
            localtime = 1
        except IndexError:
            localtime = None
        try:
            address = args[0]
        except IndexError:
            return self.error(0, "ARG", "Missing address to check.")

        try:
            sender = args[1]
        except IndexError:
            sender = None

        try:
            addr = Address.Factory(address)
            if type(addr) == Address.Address:
                raise
            addr.verify(sender)
            self.outputData("STATUS: VALID")
            try:
                self.outputData("EXPIRES: %s" % addr.timestamp(1, localtime))
            except AttributeError:
                # this is not a dated address
                pass
        except Address.AddressError, msg:
            self.outputData("STATUS:" + str(msg))
        except:
            self.outputData("STATUS: couldn't check the address")


    def help_address(self):
        print "Write me!"

    def do_address(self, args):
        """Generate a tagged address."""
        if not self.authenticated:
            return self.error(0, "AUTH", "Please authenticate first.")
        (opts, args)  = self.parseArgs(args, 'd:k:s:b',
                                            [ 'dated=',
                                              'keyword=',
                                              'sender=',
                                              'base',
                                            ] )
        from TMDA import Address
        tag = 'dated'
        date = '5d'
        param = None
        for (opt, arg) in opts:
            if opt in ('-b', '--base'):
                self.outputData(Address.Address().base())
                return 0
            elif opt in ('-d', '--dated'):
                tag = 'dated'
                param = arg
            elif opt in ('-k', '--keyword'):
                tag = 'keyword'
                param = arg
            elif opt in ('-s', '--sender'):
                tag = 'sender'
                param = arg
            elif opt in ('-a', '--address'):
                address = arg

        try:
            address = args[0]
        except IndexError:
            address = None

        if param is None:
            if tag != 'dated':
                return self.error(0, "ARG", "Missing or malformed parameter.")
            else:
                param = date
        try:
            tagged_address = Address.Factory(tag = tag).create(address, param).address
        except ValueError, msg:
            return self.error(0, "UNK", "Unknown error (Address.Factory).")
        if not tagged_address:
            return self.error(0, "UNK", "Unknown error (Address.Factory).")
        self.outputData(tagged_address)
        return 0

    def help_pending(self):
        print "Write me!"

    def do_pending(self, args):
        """List pending message ids."""
        if not self.authenticated:
            return self.error(0, "AUTH", "Please authenticate first.")
        (opts, args) = self.parseArgs(args, 'qacrdoD:',
                                            [ 'queue',
                                              'all', 
                                              'confirmed',
                                              'released',
                                              'delivered',
                                              'only',
                                              'descending=',
                                            ] )
        try:
            (opt, arg) = opts[0]
        except IndexError:
            (opt, arg) = ('-o', '')
        descending = None
        for (o, a) in opts:
            if o == '-D' or o == '--descending':
                if a:
                    descending = 1 
                break
        descending = 1 
        from TMDA import Pending
        if opt == '-q' or opt == '--queue':
            Pending.InteractiveQueue().initQueue().mainLoop()
            return 0
        ids = ''
        if opt == '-a' or opt == '--all':
            ids = Pending.Queue(descending=descending).initQueue().listIds()
        elif opt == '-c' or opt == '--confirmed':
            ids = Pending.Queue(descending=descending).initQueue().listConfirmedIds()
        elif opt == '-r' or opt == '--released':
            ids = Pending.Queue(descending=descending).initQueue().listReleasedIds()
        elif opt == '-d' or opt == '--delivered':
            ids = Pending.Queue(descending=descending).initQueue().listDeliveredIds()
        elif opt == '-o' or opt == '--only':
            ids = Pending.Queue(descending=descending).initQueue().listPendingIds()
        if ids:
            self.outputData(ids)
        else:
            self.outputData('nothing'+opt)
        return 0

    def help_message(self):
        print "Write me!"

    def do_message(self, args):
        """Do action on message."""
        if not self.authenticated:
            return self.error(0, "AUTH", "Please authenticate first.")
        (opts, args)  = self.parseArgs(args, 'tsSrdwbD:',
                                             [ 'terse',
                                               'summary',
                                               'show',
                                               'release',
                                               'delete',
                                               'whitelist',
                                               'blacklist',
                                               'date=',
                                             ] )
        try:
            (opt, arg) = opts[0]
        except IndexError:
            (opt, arg) = ('-t', '')
        date = 0
        for (o, a) in opts:
            if o == '-D' or o == '--date':
                if a:
                    date = 1
                break
        from TMDA import Pending
        if not len(args):
            return self.error(0, 'ARG', 'Missing message id.')
        if opt == '-t' or opt == '--terse':
            for l in Pending.Message(args[0]).initMessage().terse(tsv=0, date=date):
                self.outputData(l.replace('\n', r'\n'))
        elif opt == '-s' or opt == '--summary':
            self.outputData(Pending.Message(args[0]).initMessage().summary())
        elif opt == '-S' or opt == '--show':
            self.outputData(Pending.Message(args[0]).initMessage().show())
        elif opt == '-r' or opt == '--release':
            Pending.Message(args[0]).initMessage().release()
        elif opt == '-d' or opt == '--delete':
            Pending.Message(args[0]).initMessage().delete()
        elif opt == '-w' or opt == '--whitelist':
            Pending.Message(args[0]).initMessage().whitelist()
        elif opt == '-b' or opt == '--blacklist':
            Pending.Message(args[0]).initMessage().blacklist()
        return 0

    def do_get(self, args):
        if not self.authenticated:
            return self.error(0, "AUTH", "Please authenticate first.")
        (opts, args)  = self.parseArgs(args)
        
        from TMDA import Defaults
        res = []
        if '*' in args:
            args = dict(Defaults).keys()
        for a in args:
            try:
                res.append('%s=%s' % (a, getattr(Defaults, a)))
            except AttributeError, msg:
                pass
                #self.error(0, 'VAR', '%s: %s' % (a, msg))
        self.outputData('\n'.join(res))
        return 0
            

    def do_exit(self, args):
        """Exit the shell."""
        print '.bye.'
        return 1

    # aliases on exit
    do_quit = do_exit
    do_EOF = do_exit

def connection(hostport):
    stdin = sys.stdin
    stdout = sys.stdout
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        (host, port) = hostport.split(':',2)
    except ValueError:
        (host, port) = (hostport, defaultport)
    if host == 'any':
        host = '0.0.0.0'
    try:
        port = int(port)
    except ValueError:
        raise IOError, "%s is not a valid port" % port
    sock.bind((host, int(port)))
    print 'Listening on %s:%s' % (host, port)
    sock.listen(5)
    try:
        while 1:
            conn, addr = sock.accept()
            pid = os.fork()
            if not pid:
                sin = conn.makefile('r', 0)
                sout = conn.makefile('w', 0)
                print 'accepted connection from %s:%s' % addr
                try:
                    TMDAShell('+', sin, sout, stdout).mainLoop()
                    sys.stdout = stdout
                except IOError, msg:
                    sys.stdout = stdout
                    print msg
                sys.stdin = stdin
                print 'closing connection from %s:%s' % addr
                sin.close()
                sout.close()
                break
            conn.close()
    except KeyboardInterrupt:
        print "Keyboard interrupt: exiting..."
        sock.close()


def main():
    if daemon_mode:
        connection(hostport)
    else:
        TMDAShell().mainLoop()

# This is the end my friend.
if __name__ == '__main__':
    main()
